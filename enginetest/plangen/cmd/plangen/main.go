// Copyright 2022 Dolthub, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"path"
	"strings"

	"gopkg.in/yaml.v3"

	"github.com/dolthub/go-mysql-server/enginetest"
	"github.com/dolthub/go-mysql-server/enginetest/queries"
	"github.com/dolthub/go-mysql-server/enginetest/scriptgen/setup"
	"github.com/dolthub/go-mysql-server/sql"
	"github.com/dolthub/go-mysql-server/sql/planbuilder"
)

//go:generate go run ./main.go -srcRoot=../../../../ plan ../../testdata/spec.yaml

var (
	errInvalidArgCount     = errors.New("invalid number of arguments")
	errUnrecognizedCommand = errors.New("unrecognized command")
)

var (
	pkg     = flag.String("pkg", "queries", "package name used in generated files")
	srcRoot = flag.String("srcRoot", "", "path to package root")
)

const useGoFmt = true

func main() {
	flag.Usage = usage
	flag.Parse()

	args := flag.Args()
	if len(args) < 2 {
		flag.Usage()
		exit(errInvalidArgCount)
	}

	cmd := args[0]
	switch cmd {
	case "plan":

	default:
		flag.Usage()
		exit(errUnrecognizedCommand)
	}

	err := generatePlans(args[1], *srcRoot)
	if err != nil {
		exit(err)
	}
}

type PlanSpecs struct {
	Plans []PlanSpec `yaml:"plans"`
}

type PlanSpec struct {
	Name string `yaml:"name"`
	Path string `yaml:"path"`
}

func ParseSpec(path string) (PlanSpecs, error) {
	contents, err := os.ReadFile(path)
	if err != nil {
		return PlanSpecs{}, err
	}
	dec := yaml.NewDecoder(bytes.NewReader(contents))
	dec.KnownFields(true)
	var res PlanSpecs
	err = dec.Decode(&res)
	return res, err
}

func generatePlans(specPath string, srcRoot string) error {
	specs, err := ParseSpec(specPath)
	if err != nil {
		exit(err)
	}
	for _, spec := range specs.Plans {
		var buf bytes.Buffer
		fmt.Fprintf(&buf, "// Code generated by plangen.\n\n")
		fmt.Fprintf(&buf, `// Copyright 2024 Dolthub, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.`)
		fmt.Fprintf(&buf, "\n\n")
		fmt.Fprintf(&buf, "package %s\n\n", *pkg)

		err = generatePlansForSuite(spec, &buf)
		if err != nil {
			exit(err)
		}
		out := path.Join(srcRoot, spec.Path)
		err = toFile(buf, out)
		if err != nil {
			exit(err)
		}
	}
	return nil
}

func generatePlansForSuite(spec PlanSpec, w *bytes.Buffer) error {
	harness := enginetest.NewMemoryHarness("default", 1, 1, true, nil)
	s := specSetup(spec.Name)
	harness.Setup(s...)
	engine, err := harness.NewEngine(nil)
	if err != nil {
		exit(err)
	}

	queries := specQueries(spec.Name)

	_, _ = fmt.Fprintf(w, "var %s = []QueryPlanTest{\n", spec.Name)
	for _, tt := range queries {
		_, _ = w.WriteString("\t{\n")

		if strings.Contains(tt.Query, "`") {
			_, _ = w.WriteString("Query: ")
			for i, line := range strings.Split(strings.TrimSpace(tt.Query), "\n") {
				if i > 0 {
					_, _ = w.WriteString(" + \n")
				}
				if len(line) > 0 {
					_, _ = w.WriteString(fmt.Sprintf(`"%s\n"`, strings.ReplaceAll(line, `"`, `\"`)))
				}
			}
			// final line with comma
			_, _ = w.WriteString(" + \n\"\",\n")
		} else {
			_, _ = w.WriteString(fmt.Sprintf("Query: `%s`,", tt.Query))
		}
		_, _ = w.WriteString("\n")

		if !tt.Skip {
			ctx := enginetest.NewContextWithEngine(harness, engine)
			binder := planbuilder.New(ctx, engine.EngineAnalyzer().Catalog, sql.NewMysqlParser())
			parsed, _, _, err := binder.Parse(tt.Query, false)
			if err != nil {
				exit(fmt.Errorf("%w\nfailed to parse query: %s", err, tt.Query))
			}
			node, err := engine.EngineAnalyzer().Analyze(ctx, parsed, nil)
			if err != nil {
				exit(fmt.Errorf("%w\nfailed to analyze query: %s", err, tt.Query))
			}

			emitPlanString := func(planString string) {
				for i, line := range strings.Split(planString, "\n") {
					if i > 0 {
						_, _ = w.WriteString(" + \n")
					}
					if len(line) > 0 {
						_, _ = w.WriteString(fmt.Sprintf(`"%s\n"`, strings.ReplaceAll(line, `"`, `\"`)))
					} else {
						// final line with comma
						_, _ = w.WriteString("\"\",\n")
					}
				}
			}

			_, _ = w.WriteString(`ExpectedPlan: `)
			emitPlanString(sql.Describe(enginetest.ExtractQueryNode(node), sql.DescribeOptions{
				Debug: true,
			}))

			if node.IsReadOnly() {
				_, _ = w.WriteString(`ExpectedEstimates: `)
				emitPlanString(sql.Describe(enginetest.ExtractQueryNode(node), sql.DescribeOptions{
					Estimates: true,
				}))
				err = enginetest.ExecuteNode(ctx, engine, node)
				if err != nil {
					exit(fmt.Errorf("%w\nfailed to execute query: %s", err, tt.Query))
				}
				_, _ = w.WriteString(`ExpectedAnalysis: `)
				emitPlanString(sql.Describe(enginetest.ExtractQueryNode(node), sql.DescribeOptions{
					Analyze:   true,
					Estimates: true,
				}))
			}
		} else {
			_, _ = w.WriteString(`Skip: true,\n`)
		}

		_, _ = w.WriteString("\t},\n")
	}
	_, _ = w.WriteString("}")

	return nil
}

func specSetup(name string) [][]setup.SetupScript {
	switch name {
	case "PlanTests":
		return setup.PlanSetup
	case "IndexPlanTests":
		return setup.ComplexIndexSetup
	case "ImdbPlanTests":
		return setup.ImdbPlanSetup
	case "TpchPlanTests":
		return setup.TpchPlanSetup
	case "TpcdsPlanTests":
		return setup.TpcdsPlanSetup
	case "IntegrationPlanTests":
		return setup.IntegrationPlanSetup
	case "TpccPlanTests":
		return setup.TpccPlanSetup
	case "GeneratedColumnPlanTests":
		return setup.GeneratedColumnSetup
	case "SysbenchPlanTests":
		return setup.SysbenchSetup
	default:
		exit(fmt.Errorf("setup not found for plan suite: %s", name))
		return nil
	}
}

func specQueries(name string) []queries.QueryPlanTest {
	switch name {
	case "PlanTests":
		return queries.PlanTests
	case "IndexPlanTests":
		return queries.IndexPlanTests
	case "ImdbPlanTests":
		return queries.ImdbPlanTests
	case "TpchPlanTests":
		return queries.TpchPlanTests
	case "TpccPlanTests":
		return queries.TpccPlanTests
	case "TpcdsPlanTests":
		return queries.TpcdsPlanTests
	case "IntegrationPlanTests":
		return queries.IntegrationPlanTests
	case "GeneratedColumnPlanTests":
		return queries.GeneratedColumnPlanTests
	case "SysbenchPlanTests":
		return queries.SysbenchPlanTests
	default:
		exit(fmt.Errorf("queries not found for plan suite: %s", name))
		return nil
	}
}

// usage is a replacement usage function for the flags package.
func usage() {
	fmt.Fprintf(os.Stderr, "Plangen generates expected plan tests .\n\n")
	fmt.Fprintf(os.Stderr, "Usage:\n")

	fmt.Fprintf(os.Stderr, "\tplangen [flags] spec\n\n")

	//fmt.Fprintf(os.Stderr, "Flags:\n")

	flag.PrintDefaults()

	fmt.Fprintf(os.Stderr, "\n")
}

func exit(err error) {
	fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
	os.Exit(2)
}

func toFile(buf bytes.Buffer, out string) error {
	var w io.Writer
	if out != "" {
		file, err := os.Create(out)
		if err != nil {
			exit(err)
		}

		defer file.Close()
		w = file
	} else {
		w = os.Stderr
	}

	var b []byte
	var err error

	if useGoFmt {
		b, err = format.Source(buf.Bytes())
		if err != nil {
			// Write out incorrect source for easier debugging.
			b = buf.Bytes()
		}
	} else {
		b = buf.Bytes()
	}

	w.Write(b)
	return err
}
