// Code generated by optgen; DO NOT EDIT.

package parse

import (
	"fmt"

	ast "github.com/dolthub/vitess/go/vt/sqlparser"

	"github.com/gabereiser/go-mysql-server/sql"
	"github.com/gabereiser/go-mysql-server/sql/plan"
)

func NewFrame(ctx *sql.Context, f *ast.Frame) (sql.WindowFrame, error) {
	if f == nil {
		return nil, nil
	}
	isRange := f.Unit == ast.RangeUnit
	isRows := f.Unit == ast.RowsUnit
	unboundedPreceding, err := getFrameUnboundedPreceding(ctx, f)
	if err != nil {
		return nil, err
	}
	startNPreceding, err := getFrameStartNPreceding(ctx, f)
	if err != nil {
		return nil, err
	}
	startCurrentRow, err := getFrameStartCurrentRow(ctx, f)
	if err != nil {
		return nil, err
	}
	startNFollowing, err := getFrameStartNFollowing(ctx, f)
	if err != nil {
		return nil, err
	}
	endNPreceding, err := getFrameEndNPreceding(ctx, f)
	if err != nil {
		return nil, err
	}
	endCurrentRow, err := getFrameEndCurrentRow(ctx, f)
	if err != nil {
		return nil, err
	}
	endNFollowing, err := getFrameEndNFollowing(ctx, f)
	if err != nil {
		return nil, err
	}
	unboundedFollowing, err := getFrameUnboundedFollowing(ctx, f)
	if err != nil {
		return nil, err
	}
	switch {
	case isRows && unboundedPreceding && endNPreceding != nil:
		return plan.NewRowsUnboundedPrecedingToNPrecedingFrame(endNPreceding), nil
	case isRows && unboundedPreceding && endCurrentRow:
		return plan.NewRowsUnboundedPrecedingToCurrentRowFrame(), nil
	case isRows && unboundedPreceding && endNFollowing != nil:
		return plan.NewRowsUnboundedPrecedingToNFollowingFrame(endNFollowing), nil
	case isRows && unboundedPreceding && unboundedFollowing:
		return plan.NewRowsUnboundedPrecedingToUnboundedFollowingFrame(), nil
	case isRows && startNPreceding != nil && endNPreceding != nil:
		return plan.NewRowsNPrecedingToNPrecedingFrame(startNPreceding, endNPreceding), nil
	case isRows && startNPreceding != nil && endCurrentRow:
		return plan.NewRowsNPrecedingToCurrentRowFrame(startNPreceding), nil
	case isRows && startNPreceding != nil && endNFollowing != nil:
		return plan.NewRowsNPrecedingToNFollowingFrame(startNPreceding, endNFollowing), nil
	case isRows && startNPreceding != nil && unboundedFollowing:
		return plan.NewRowsNPrecedingToUnboundedFollowingFrame(startNPreceding), nil
	case isRows && startCurrentRow && endNPreceding != nil:
		return plan.NewRowsCurrentRowToNPrecedingFrame(endNPreceding), nil
	case isRows && startCurrentRow && endCurrentRow:
		return plan.NewRowsCurrentRowToCurrentRowFrame(), nil
	case isRows && startCurrentRow && endNFollowing != nil:
		return plan.NewRowsCurrentRowToNFollowingFrame(endNFollowing), nil
	case isRows && startCurrentRow && unboundedFollowing:
		return plan.NewRowsCurrentRowToUnboundedFollowingFrame(), nil
	case isRows && startNFollowing != nil && endNPreceding != nil:
		return plan.NewRowsNFollowingToNPrecedingFrame(startNFollowing, endNPreceding), nil
	case isRows && startNFollowing != nil && endCurrentRow:
		return plan.NewRowsNFollowingToCurrentRowFrame(startNFollowing), nil
	case isRows && startNFollowing != nil && endNFollowing != nil:
		return plan.NewRowsNFollowingToNFollowingFrame(startNFollowing, endNFollowing), nil
	case isRows && startNFollowing != nil && unboundedFollowing:
		return plan.NewRowsNFollowingToUnboundedFollowingFrame(startNFollowing), nil
	case isRange && unboundedPreceding && endNPreceding != nil:
		return plan.NewRangeUnboundedPrecedingToNPrecedingFrame(endNPreceding), nil
	case isRange && unboundedPreceding && endCurrentRow:
		return plan.NewRangeUnboundedPrecedingToCurrentRowFrame(), nil
	case isRange && unboundedPreceding && endNFollowing != nil:
		return plan.NewRangeUnboundedPrecedingToNFollowingFrame(endNFollowing), nil
	case isRange && unboundedPreceding && unboundedFollowing:
		return plan.NewRangeUnboundedPrecedingToUnboundedFollowingFrame(), nil
	case isRange && startNPreceding != nil && endNPreceding != nil:
		return plan.NewRangeNPrecedingToNPrecedingFrame(startNPreceding, endNPreceding), nil
	case isRange && startNPreceding != nil && endCurrentRow:
		return plan.NewRangeNPrecedingToCurrentRowFrame(startNPreceding), nil
	case isRange && startNPreceding != nil && endNFollowing != nil:
		return plan.NewRangeNPrecedingToNFollowingFrame(startNPreceding, endNFollowing), nil
	case isRange && startNPreceding != nil && unboundedFollowing:
		return plan.NewRangeNPrecedingToUnboundedFollowingFrame(startNPreceding), nil
	case isRange && startCurrentRow && endNPreceding != nil:
		return plan.NewRangeCurrentRowToNPrecedingFrame(endNPreceding), nil
	case isRange && startCurrentRow && endCurrentRow:
		return plan.NewRangeCurrentRowToCurrentRowFrame(), nil
	case isRange && startCurrentRow && endNFollowing != nil:
		return plan.NewRangeCurrentRowToNFollowingFrame(endNFollowing), nil
	case isRange && startCurrentRow && unboundedFollowing:
		return plan.NewRangeCurrentRowToUnboundedFollowingFrame(), nil
	case isRange && startNFollowing != nil && endNPreceding != nil:
		return plan.NewRangeNFollowingToNPrecedingFrame(startNFollowing, endNPreceding), nil
	case isRange && startNFollowing != nil && endCurrentRow:
		return plan.NewRangeNFollowingToCurrentRowFrame(startNFollowing), nil
	case isRange && startNFollowing != nil && endNFollowing != nil:
		return plan.NewRangeNFollowingToNFollowingFrame(startNFollowing, endNFollowing), nil
	case isRange && startNFollowing != nil && unboundedFollowing:
		return plan.NewRangeNFollowingToUnboundedFollowingFrame(startNFollowing), nil
	}
	return nil, fmt.Errorf("no matching constructor found for frame: %v", f)
}
