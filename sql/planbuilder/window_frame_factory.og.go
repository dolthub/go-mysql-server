// Code generated by optgen; DO NOT EDIT.

package planbuilder

import (
	"fmt"

	ast "github.com/dolthub/vitess/go/vt/sqlparser"

	"github.com/dolthub/go-mysql-server/sql"
	"github.com/dolthub/go-mysql-server/sql/plan"
)

func (b *PlanBuilder) NewFrame(inScope *scope, f *ast.Frame) sql.WindowFrame {
	if f == nil {
		return nil
	}
	isRange := f.Unit == ast.RangeUnit
	isRows := f.Unit == ast.RowsUnit
	unboundedPreceding := b.getFrameUnboundedPreceding(inScope, f)
	startNPreceding := b.getFrameStartNPreceding(inScope, f)
	startCurrentRow := b.getFrameStartCurrentRow(inScope, f)
	startNFollowing := b.getFrameStartNFollowing(inScope, f)
	endNPreceding := b.getFrameEndNPreceding(inScope, f)
	endCurrentRow := b.getFrameEndCurrentRow(inScope, f)
	endNFollowing := b.getFrameEndNFollowing(inScope, f)
	unboundedFollowing := b.getFrameUnboundedFollowing(inScope, f)
	switch {
	case isRows && unboundedPreceding && endNPreceding != nil:
		return plan.NewRowsUnboundedPrecedingToNPrecedingFrame(endNPreceding)
	case isRows && unboundedPreceding && endCurrentRow:
		return plan.NewRowsUnboundedPrecedingToCurrentRowFrame()
	case isRows && unboundedPreceding && endNFollowing != nil:
		return plan.NewRowsUnboundedPrecedingToNFollowingFrame(endNFollowing)
	case isRows && unboundedPreceding && unboundedFollowing:
		return plan.NewRowsUnboundedPrecedingToUnboundedFollowingFrame()
	case isRows && startNPreceding != nil && endNPreceding != nil:
		return plan.NewRowsNPrecedingToNPrecedingFrame(startNPreceding, endNPreceding)
	case isRows && startNPreceding != nil && endCurrentRow:
		return plan.NewRowsNPrecedingToCurrentRowFrame(startNPreceding)
	case isRows && startNPreceding != nil && endNFollowing != nil:
		return plan.NewRowsNPrecedingToNFollowingFrame(startNPreceding, endNFollowing)
	case isRows && startNPreceding != nil && unboundedFollowing:
		return plan.NewRowsNPrecedingToUnboundedFollowingFrame(startNPreceding)
	case isRows && startCurrentRow && endNPreceding != nil:
		return plan.NewRowsCurrentRowToNPrecedingFrame(endNPreceding)
	case isRows && startCurrentRow && endCurrentRow:
		return plan.NewRowsCurrentRowToCurrentRowFrame()
	case isRows && startCurrentRow && endNFollowing != nil:
		return plan.NewRowsCurrentRowToNFollowingFrame(endNFollowing)
	case isRows && startCurrentRow && unboundedFollowing:
		return plan.NewRowsCurrentRowToUnboundedFollowingFrame()
	case isRows && startNFollowing != nil && endNPreceding != nil:
		return plan.NewRowsNFollowingToNPrecedingFrame(startNFollowing, endNPreceding)
	case isRows && startNFollowing != nil && endCurrentRow:
		return plan.NewRowsNFollowingToCurrentRowFrame(startNFollowing)
	case isRows && startNFollowing != nil && endNFollowing != nil:
		return plan.NewRowsNFollowingToNFollowingFrame(startNFollowing, endNFollowing)
	case isRows && startNFollowing != nil && unboundedFollowing:
		return plan.NewRowsNFollowingToUnboundedFollowingFrame(startNFollowing)
	case isRange && unboundedPreceding && endNPreceding != nil:
		return plan.NewRangeUnboundedPrecedingToNPrecedingFrame(endNPreceding)
	case isRange && unboundedPreceding && endCurrentRow:
		return plan.NewRangeUnboundedPrecedingToCurrentRowFrame()
	case isRange && unboundedPreceding && endNFollowing != nil:
		return plan.NewRangeUnboundedPrecedingToNFollowingFrame(endNFollowing)
	case isRange && unboundedPreceding && unboundedFollowing:
		return plan.NewRangeUnboundedPrecedingToUnboundedFollowingFrame()
	case isRange && startNPreceding != nil && endNPreceding != nil:
		return plan.NewRangeNPrecedingToNPrecedingFrame(startNPreceding, endNPreceding)
	case isRange && startNPreceding != nil && endCurrentRow:
		return plan.NewRangeNPrecedingToCurrentRowFrame(startNPreceding)
	case isRange && startNPreceding != nil && endNFollowing != nil:
		return plan.NewRangeNPrecedingToNFollowingFrame(startNPreceding, endNFollowing)
	case isRange && startNPreceding != nil && unboundedFollowing:
		return plan.NewRangeNPrecedingToUnboundedFollowingFrame(startNPreceding)
	case isRange && startCurrentRow && endNPreceding != nil:
		return plan.NewRangeCurrentRowToNPrecedingFrame(endNPreceding)
	case isRange && startCurrentRow && endCurrentRow:
		return plan.NewRangeCurrentRowToCurrentRowFrame()
	case isRange && startCurrentRow && endNFollowing != nil:
		return plan.NewRangeCurrentRowToNFollowingFrame(endNFollowing)
	case isRange && startCurrentRow && unboundedFollowing:
		return plan.NewRangeCurrentRowToUnboundedFollowingFrame()
	case isRange && startNFollowing != nil && endNPreceding != nil:
		return plan.NewRangeNFollowingToNPrecedingFrame(startNFollowing, endNPreceding)
	case isRange && startNFollowing != nil && endCurrentRow:
		return plan.NewRangeNFollowingToCurrentRowFrame(startNFollowing)
	case isRange && startNFollowing != nil && endNFollowing != nil:
		return plan.NewRangeNFollowingToNFollowingFrame(startNFollowing, endNFollowing)
	case isRange && startNFollowing != nil && unboundedFollowing:
		return plan.NewRangeNFollowingToUnboundedFollowingFrame(startNFollowing)
	default:
		err := fmt.Errorf("no matching constructor found for frame: %v", f)
		b.handleErr(err)
		return nil
	}
}
